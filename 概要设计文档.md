# 概要设计文档

## 1. 总体架构
- UI 层：`Maingame` 主窗口负责场景绘制、牌面控件管理、按钮与标签布局、动画与倒计时显示。
- 控制层：`gamecontrol` 实现发牌/抢地主/出牌状态机，维护当前玩家、牌池、出牌记录，并通过信号与 UI 同步。
- 参与者模型：基类 `player` 抽象公共属性与信号，`user` 负责人机交互，`robot` 通过线程封装 AI 行为。
- 规则与策略：`PlayHand` 负责牌型识别与压制判断；`Strategy` 为机器人选择首出/压牌方案。
- 视听模块：`AnmationPixmap` 播放顺子/炸弹/飞机等动画；`Bgmcontrol` 统一管理男女语音、背景音乐与特效音。
- 资源层：`res.qrc` 与 `conf/playList.json` 提供图片、音频与播放列表，避免外部依赖。

## 2. 模块关系与数据流
- 启动链路：`main` → `Loadprocess` → 创建 `Maingame`。
- 信号/槽：
  - `gamecontrol::S_gameStateChange` 驱动 `Maingame` 切换阶段与按钮组。
  - `player::notifygrablordbet`、`notifyplayhand` 触发 `gamecontrol` 处理叫分与出牌。
  - `gamecontrol::S_gamePlayHand` 通知 UI 刷新出牌/要不起展示并播放音效。
  - `gamecontrol::S_StopCountdown` 控制倒计时显示/隐藏。
- AI 线程：`Robotgetloard`、`RobotPlayhand` 在线程中延时调用机器人逻辑，结果仍经 `player` 信号进入 `gamecontrol`。
- 资源加载：`Bgmcontrol::InitMusicPlayer` 读取播放列表；`Maingame::InitCardpanelMap` 从雪碧图切牌。

## 3. 主要流程（阶段化）
- 启动/加载：显示进度条 → 进入主界面。
- 发牌：`SetCurrentGameStatue(PENDCARD)` 启动发牌定时器，分发 51 张手牌 + 3 张底牌展示。
- 抢地主：按顺序叫分，三轮后确定地主并将底牌发给地主，切换到出牌阶段。
- 出牌：当前玩家准备出牌（倒计时），校验牌型与压制，更新手牌、出牌记录与 UI。
- 结算/重开：分数计算、结算面板/音效 → 点击“继续”重置状态并重新发牌。

## 4. 界面结构与布局
- 三个座位：手牌区（水平/垂直）、出牌区、头像、提示标签（要不起/叫分/角色）。
- 按钮组：通过 stackedWidget 切换“开始”“出牌/要不起”“首出”“叫分”四类控件。
- 动画与倒计时：中心显示牌型动画，底部显示倒计时控件；顶部居中展示地主牌。

## 5. 关键数据结构
- `Card`（点数/花色）、`Cards`（QSet<Card*>）支持随机取牌、按值删除、排序（升/降）、判空与计数。
- `_Playercontext`：手牌/出牌区域坐标、头像/提示坐标、要不起标签、角色标签、最后出牌记录、翻面标记。
- `Betrest`：叫分状态（轮次、最高分、对应玩家）。

## 6. 关键流程说明（文字）
- 发牌：计时器驱动 `_MoveCards` 移动到不同座位 → 底牌生成面板 → 发牌音效停止 → 切换抢地主。
- 抢地主：记录最高分与首家标记，三轮后若无人叫分则重发牌；否则设置地主、分发底牌、进入出牌状态。
- 出牌：用户/机器人选牌 → `PlayHand` 判型 → 与上家比较 → 更新手牌/出牌记录 → 轮转到下家；要不起则仅轮转且展示“要不起”标签与音效。
